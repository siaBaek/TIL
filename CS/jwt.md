# JWT

무엇이고 왜 쓰는 것일까?

## HTTP 통신의 특징

1. connectionless

- HTTP는 연결을 유지하지 않는다
- 서버와 클라이언트가 한 번 통신이 일어나고 나면 그 연결이 바로 끊어진다

2. stateless

- HTTP는 상태를 유지하지 않는다
- 서버와 클라이언트는 첫 번째 통신을 하고 나서 두 번째 통신을 할 때는 이전 통신에 대한 정보를 가지고 있지 않다

## 로그인 유지

- 이러한 HTTP 특징때문에 로그인 구현에 많은 어려움이 있다
  - 사용자는 자신이 누구인지 계속해서 인증을 해야하게 되며, 매번 서버에 요청을 보내야 하기 때문에 웹페이지가 느려지는 원인이 된다
- 사용자가 누구인지 계속해서 인증하는 방법 대신 다른 로그인 정보를 유지시킬 방법이 필요하다

### 세션 방식 (서버 유지)

![세션](https://velog.velcdn.com/images%2Fjunghyeonsu%2Fpost%2F7f05d33e-520c-4617-9776-183a0d9611d5%2Fimage.png)

- 서버의 메모리, 데이터베이스와 같은 서버의 자원을 사용해서 사용자 정보를 유지시키는 방식
- 장점
  - 토큰 방식보다 보안에 강하다
- 단점
  - 서버의 자원(세션을 저장하고 유지할 공간)이 많이 필요하다
  - 서버의 확장성이 떨어진다. 즉, 트래픽 분산을 위해 여러 대의 서버를 사용할 때 처음 로그인한 서버에만 요청을 보내야 한다

### 토큰 방식 (클라이언트 유지)

- 사용자가 로그인을 하면 서버에 발행해주는 토큰(JWT)을 가지고 브라우저의 저장소에 토큰(JWT)을 유지시키는 방법
- 장점
  - 서버에 저장하기 않기 때문에 서버의 확장성이 있다
  - 즉, 요청이 들어왔을 때 해당 토큰이 유효한지만 체크하면 되기 때문에 어떤 서버로 요청을 보내도 상관이 없다

## JWT

- JSON Web Token
- 두 개체 사이에서 안정성있게 정보를 교환하기 좋은 방법
- 전자서명된 URL-safe(URL로 이용할 수 있는 문자만 구성된)의 JSON

![JWT구조](https://velog.velcdn.com/images%2Fjunghyeonsu%2Fpost%2F088b6452-fc1b-49e3-8a57-45236a000e86%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-09-14%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.21.53.png)

- JWT는 .을 기준으로 세 개의 파트로 나뉜다

1. header

- JWT를 어떻게 검증하는지에 대한 내용
- 토큰의 타입, 암호화 알고리즘이 어떤 알고리즘인지에 대한 정보
- 해시 알고리즘의 이름을 적어줄 수 있다

2. payload

- 우리가 보내고자 하는 데이터가 담겨져 있다
- 이 정보의 조각은 클레임(claim)이라고 하고 key-value의 한 쌍으로 이루어져 있다
- payload에는 여러 개의 claim을 담을 수 있고, 클레임을 공개 혹은 비공개할 것인지 등록할 것인지 결정할 수 있다

3. signature

- header와 payload를 합친 문자열을 서명한 값
- 서명은 header의 alg에 정의된 알고리즘과 secret key를 이용하여 생성하고 Base64 URL-Safe로 인코딩한다
- secret key를 포함해서 암호화가 되어있다

![JWT예시](https://velog.velcdn.com/images%2Fjunghyeonsu%2Fpost%2Ff651801b-8494-4913-82c6-ff89f8bbd59f%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-09-15%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%208.45.47.png)

- 생성된 JWT는 .를 구분자로 header, payload, signature로 나눠서 서로 전달하게 되고, 서버는 헤더의 alg, kid 속성과 공개키를 이용해 검증할 수 있다
- 검증이 성공하면 payload 값으로 접근하여 사용할 수 있다

### 공개키와 비밀키

- JWT에서는 기본적으로 공개키 암호화 방식을 사용하는데, 비대칭 암호 방식을 이용하여 공개키와 비밀키를 생성하고 이 키들을 상황에 따라 나누어 통신한다
- 서명은 비밀키가 있는 곳에서만 할 수 있고 공개키를 가진 어느 곳에서나 이 데이터의 서명을 검증할 수 있다
- 공개키를 가진 누구나 데이터를 암호화해서 데이터를 보낼 수 있지만,
- 비밀키를 가진 곳에서만 데이터를 복호화해서 내용을 확인할 수 있다
- 비밀키로 암호화한 데이터는 다시 비밀키로 풀 수 없고, 공개키로 암호화한 데이터는 다시 공개키로 풀 수 없다

<br/>

- 서명: 비밀키를 가진 극소수만 데이터에 서명할 수 있다. 공개키를 가진 아무나 데이터의 서명을 검증할 수 있다
- 암호화: 공개키를 가진 아무나 데이터를 암호화할 수 있다. 비밀키를 가진 극소수만 데이터를 복호화해 확인할 수 있다

## JWT 장단점

1. 장점

- 서버와의 커뮤니케이션을 최소화할 수 있다
- 트래픽에 대한 부담이 적다
- 세션과 다르게 독립적인 JWT를 활용한다는 것

2. 단점

- JWT 크기가 커질수록 거의 모든 요청에 대해 전송하므로 데이터 트래픽 크기에 영향을 미칠 수 있다
- 토큰은 클라이언트에 저장되기 때문에 DB에서 사용자 정보를 수정하더라도 토큰에 직접 적용할 수 없다

## JWT 프로세스

### Access Token만 사용

1. 사용자가 로그인 정보 입력하고 서버에 로그인 요청
2. 서버는 비밀키를 통해 서명하고 공캐키로 암호화 시킨 Access Token 발급
3. Access Token을 사용자(클라이언트)에게 전송 (로그인 완료)
4. 로그인 정보가 필요한 API 요청마다 토큰을 실어서 보낸다
   - 사용자(클라이언트)는 API를 요청할 때 Authorization Header에 Access Token을 담아서 보낸다
5. 서버에서는 사용자(클라이언트)가 보낸 토큰을 공개키로 서명을 체크하고 안에 담긴 정보를 확인한다
   - 서버는 secret key로 사용자가 보낸 토큰의 서명을 복호화해서 유효한 토큰인지 확인
6. 서버가 요청에 대한 응답을 사용자(클라이언트)에게 전달한다

### Refresh Token과 함께 사용

- Access Token 만을 사용했을 때 보안 문제를 해결하기 위해 나온 Refresh Token

<br />

- Access Token을 탈취당하면 문제가 생긴다
- 유효기간이 긴 토큰이라면 그 시간동안 정보를 탈취당하게 되고, 유효기간을 줄이자니 사용자가 로그인을 자주 해야하는 번거로움이 있다
- 그래서 나온 것이 Refresh Token
- Refresh Token 또한 Access Token과 같은 JWT
- 로그인했을 때 서버에서 Access Token과 Refresh Token을 동시에 보내주는데 단, 두 토큰의 유효기간을 다르게 설정하여 보낸다
- Refresh Token은 한 달, Access Token은 하루로 설정했다면 하루가 지낫Access Token의 기간이 다 되어도 기간이 남은 Refresh Token을 가지고 Access Token을 발급받을 수 있다

<br />

- Refresh Token은 Access Token을 재발급 받기 위한 JWT

## 토큰 저장 위치

- 개발자의 취향과 장단점이 서로 다르다

1. localStorage

- XSS(공격자가 클라이언트 브라우저에 스크립트를 삽입하여 공격)에 취약

2. 쿠키

- XSS & CSRF(다른 도메인에서 우리 도메인으로 API Call을 날리는 공격)에 취약

3. secure httpOnly

- CSRF에 취약

## 결론

- HTT의 비연결성, 무상태 특성에 의해 로그인 정보를 유지시키기 위해 알맞은 유지 방법이 필요하다
- JWT는 암호화, 복호화를 통해 두 개체 사이에서 정보를 안전하게 주고 받기 위한 좋은 수단이다
- 필요한 API
  - Refresh API
    - 새로고침, Access Token 만료 시 호출 (setTimeout으로 자동 호출 설정 가능)
    - RefreshToken을 쿠키에서 읽어와서 서버로 보냄
    - RefreshToken, AccessToken을 다 받아올지 AccessToken만 받아올지는 선택
  - Login API
    - 로그인 시 호출
    - Refresh Token, Access Token을 받아옴
  - API 호출 후
    - Access Token은 header에 default로 설정하여 API마다 보내도록 설정
    - Access Token의 유효기간이 끝나기 전 자동으로 Refresh API가 호출되도록 설정 가능(선택적)
    - Refresh Token은 쿠키에 저장 (기간 만료되면 재로그인 필요)
