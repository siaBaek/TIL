# Data Structure

1. 단일 연결 리스트
2. 이중 연결 리스트
3. 큐
4. 스택
5. 해시 테이블
6. 힙
7. 우선순위 큐
8. 트라이
9. 트리
   1. 이진 탐색 트리
   2. AVL 트리
   3. Red-Black 트리
   4. 세그먼트 트리
   5. Fenwick 트리
10. 그래프
11. 서로소 집합
12. 블룸 필터

<hr />

## 단일 연결 리스트 (Singly Linked List)

![링크드 리스트](https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg)

- 데이터 요소의 선형 집합
- 논리적 저장 순서는 메모리의 물리적 저장 순서와 일치하지 않는다
- 순서를 표현하는 노드들의 집합으로 이루어져 있다
- 각각 노드들은 데이터와 다음 노드를 가리키는 레퍼런스(링크)로 이루어져 있다
- 링크는 다음 데이터를 가리키며 링크를 통해 데이터를 추가/삭제/탐색 등을 할 수 있다
- 순회하는 동안 순서에 상관없이 효율적인 삽입/삭제가 가능하다
- 링크 하나에 4byte 메모리를 차지하며, 더블 링크드일 경우엔 노드 하나에 8byte의 링크 메모리를 차지한다

<hr />

## 이중 연결 리스트 (Doubly Linked List)

![이중 연결 리스트](https://upload.wikimedia.org/wikipedia/commons/5/5e/Doubly-linked-list.svg)

- 순차적으로 링크된 노드라는 레코드 세트로 구성된 연결 데이터 구조
- 각 노드에는 링크라고 하는 두 개의 필드가 있으며, 노드 순서에서 이전 노드와 다음 노드에 대한 레퍼런스를 가진다
- 시작 및 종료 노드의 이전 및 다음 링크는 각각 리스트의 순회를 용이하기 위해 일종의 종결자(센티넬코드 또는 null)을 나타낸다
- 센티넬 노드가 하나만 있으면, 목록이 센티넬 노드를 통해서 원형으로 연결된다
- 동일한 데이터 항목으로 구성되어 있지만, 반대 순서로 두 개의 단일 연결 리스트로 개념화할 수 있다
- 두 개의 노드 링크를 사용하면 어느 방향으로든 리스트를 순회할 수 있다
- 이중 연결 리스트에서 노드를 삽입/삭제 하려면, 단일 연결 리스트보다 더 많은 링크를 변경해야 하지만, 첫 번째 노드 이외의 노드인 경우 작업을 추적할 필요가 없으므로 작업이 더 단순해져 잠재적으로 더 효율적이다
- 리스트 순회 중 이전 노드 또는 링크를 수정할 수 있도록 이전 노드를 찾기 위해 리스트를 순회할 필요가 없다

<hr />

## 큐

![Queue](https://upload.wikimedia.org/wikipedia/commons/5/52/Data_Queue.svg)

- 일종의 추상 데이터 타입이자 컬렉션
- 큐 내부 엔티티(Entity, 개체)들은 순서를 유지한다
- 인큐(Enqueue): 컬렉션의 가장 뒷 부분에 엔티티를 추가
- 디큐(Dequeue): 컬렉션의 가장 앞에 위치한 엔티티를 제거
- 이것은 큐를 선입선출 자료 구조로 만든다 (추가된 첫 번째 요소가 가장 먼저 제거)
- 이는 새로운 요소가 추가되면 이전에 추가되었던 모든 요소들을 제거해야 새로운 요소를 제거할 수 있다는것과 같은 의미
- 또한 큐의 가장 앞에 위치한 요소를 반환하기 위한 작업이 입력되면 디큐 작업 없이 해당 요소를 반환한다
- 큐는 선형 자료 구조의 예시이며, 더 추상적으로는 순차적인 컬렉션이다

<hr />

## 스택

![Stack](https://upload.wikimedia.org/wikipedia/commons/b/b4/Lifo_stack.png)

- 아래의 두 가지 연산을 가진 요소들의 집합인 추상 자료형
  - push는 집합에 요소를 추가하는 것이며,
  - pop은 아직 제거되지 않은 가장 최근에 추가된 요소를 제거하는 연산
- 요소가 스택에서 나오는 과정은 LIFO(Last In, First Out, 후입선출)라는 이름으로 확인이 가능하다
- 즉, 나중에 들어간 것이 먼저 나오는 구조이다
- 물건들이 다른 물건들 위에 쌓이게 되는 것에서 유추된 이름
- 최상단 물건은 빼내기 쉽지만, 깊이 있는 물건을 빼내려면 다른 물건들을 먼저 빼내야 하는 작업이 필요하다

<hr />

## 해시 테이블

![Hash Table](https://upload.wikimedia.org/wikipedia/commons/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg)

- 키(key)를 값(value)에 매핑할 수 있는 구조인 연관 배열을 구현하는 자료 구조
- 해시 함수를 사용해 원하는 값을 담을 수 있는 버킷 또는 슬롯 배열의 인덱스를 계산한다
- 이상적으로, 해시 함수는 각 키들을 고유 버킷에 할당하지만,
- 대부분의 해시 테이블은 불완전한 해시 함수를 사용하기 때문에
- 해시 함수를 통해 두 개 이상의 키에 대해 동일한 인덱스를 생성하는 해시 충돌이 발생할 수 있다
- 이러한 해시 충돌은 어떠한 방법으로든 해결되어야 한다
- 다음은 분리 연결법을 통해 해시 충돌을 해결한 예시이다.
  ![Hash Collision](https://upload.wikimedia.org/wikipedia/commons/d/d0/Hash_table_5_0_1_1_1_1_1_LL.svg)

<hr />

## 힙

- 아래에 설명된 힙 속성을 만족하는 전문화된 트리 기반 데이터구조

### 최소 힙

![MinHeap](https://upload.wikimedia.org/wikipedia/commons/6/69/Min-heap.png)

- 최소 힙에서 `P`가 `C`의 상위 노드라면 `P`의 키(값)는 `C`의 키보다 작거나 같다
- 각 노드의 키(Key)값이 (자식 노드가 있다면) 그 자식의 키(Key)값보다 크지 않은(=작거나 같은) 트리
- 최소 트리이면서 완전 이진 트리이다 (완전 이진 트리: 노드를 삽입할 때, 왼쪽부터 차례대로 삽입하는 트리)

### 최대 힙

![MaxHeap](https://upload.wikimedia.org/wikipedia/commons/3/38/Max-Heap.svg)

- 최대 힙에서 `P`의 키는 `C`의 키보다 크거나 같다
- 각 노드의 키(Key)값이 (자식 노드가 있다면) 그 자식의 키(Key)값보다 작지 않은(=크거나 같은) 트리
- 최대 트리이면서 완전 이진 트리이다 (완전 이진 트리: 노드를 삽입할 때, 왼쪽부터 차례대로 삽입하는 트리)
- 상위 노드가 없는 힙의 상단에 있는 노드를 루트 노드라고 한다

<hr />

## 우선순위 큐

- 일반 큐 또는 스택 구조 같은 추상 데이터 유형이지만, 각 요소에 우선 순위가 연결된다
- 우선 순위가 높은 요소가 낮은 요소 앞에 제공된다
- 두 요소가 동일한 우선 순위를 가질 경우 큐의 순서에 따른다

<hr />

## 트라이

![Trie](https://upload.wikimedia.org/wikipedia/commons/b/be/Trie_example.svg)

- retrieval(검색)에서 유래하였고,  tree와 구분하기 위하여 트라이라고 발음하는 사람이 많다고 한다
- 디지털 트리(digital tree), 기수 트리(radix tree), 접두사 트리(prefix tree), prefixes 라고도 한다
- 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조이다
- 많은 양의 텍스트정보를 빠르고 효율적으로 검색하기 위해 사용한다
- 사전 혹은 인터넷 자동완성의 retrieval을 효과적으로 할 수 있는 자료구조이다
- 기본적으로 k진 트리(k-ary tree) 구조를 띠고 있다
- 일종의 검색 트리로, 키가 보통 문자열인 동적 셋이나 연관 배열을 저장하기 위해 사용되는 정렬된 트리 데이터 구조이다
- 이진 검색 트리와 달리, 트리의 어떤 노드도 해당 노드와 연관된 키를 저장하지 않는 대신에 트리에서의 노드 위치가 연관된 키를 정의한다
- 이것은 데이터 구조 전체에 걸쳐 각 키의 값을 분배하며 모든 노드에 반드시 연관된 값이 있는 것이 있는 것은 아니다 (값이 모든 노드와 반드시 연관되지는 않는다)
- 오히려 값은 말단 노드(leaves)와 특정 키에 해당하는 일부 내부 노드(inner)와만 연관되는 경향이 있다
- 키워드 정보는 말단 노드가 가지고 있고, 나머지 노드들은 정보는 없고 링크만 가지게 된다
- 노드의 모든 자식 노드는 해당 부모 노드와 연결된 문자열의 공통 접두사를 가지며, 루트는 빈 문자열과 연결된다
- 접두사로 액세스할 수 있는 데이터를 저장하는 이 작업은 기수 트리를 사용하여 메모리 최적화 방식으로 수행할 수 있다
- prefix tree의 공간 최적화 표시는 compact prefix tree를 참조

<hr />

## 트리

![Tree](https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_tree.svg)

🔼 7이라는 레이블이 지정된 노드에는 2와 6이라는 레이블이 지정된 두 개의 자식과 2라는 레이블이 지정된 한 개의 부모가 있다

- 연결된 노드 집합이 있는 계층적 트리 구조를 나타내는 널리 사용되는 추상 데이터타입(abstract data type, ADT)
- 루트 노드에서 시작하는 노드들의 집합으로 재귀적으로 정의될 수 있다
- 각 노드는 노드(자식)에 대한 참조 목록과 함께 값으로 구성된 데이터 구조
- 각 노드는 많은 자식에 연결될 수 있지만, 부모가 없는 루트 노드를 제외하고는 정확히 하나의 부모에만 연결되어야 한다

<br />

### 이진 탐색 트리

![Binary Search Tree](https://upload.wikimedia.org/wikipedia/commons/d/da/Binary_search_tree.svg)

🔼 크기가 9이고 깊이가 3이고 루트가 8인 이진 검색 트리 (말단 노드가 그려지지 않았다)

- 다음과 같은 속성이 있는 이진 트리 자료 구조라고 할 수 있다

  - 각 노드에 값이 있다
  - 값들은 전순서가 있다
  - 노드의 왼쪽 서브트리에는 그 노드의 값보다 작은 값들을 지닌 노드들로 이루어져 있다
  - 노드의 오른쪽 서브트리에는 그 노드의 값보다 큰 값들을 지닌 노드들로 이루어져 있다
  - 좌우 하위 트리는 각각이 다시 이진 탐색 트리여야 한다

- ordered binary tree 또는 sorted binary tree라고 부르기도 한다
- 특정 유형의 컨테이너 즉, 메모리에 아이템(숫자, 이름 등)을 저장하는 데이터 구조이다
- 빠른 검색, 삽입, 삭제가 가능하다
- 아이템의 동적 셋 또는 키로 항목을 찾을 수 있는 룩업 테이블(예: 이름으로 사용자의 전화 번호 찾기)을 구현하는데 사용할 수 있다
- 키를 정렬된 순서대로 유지하므로 룩업 및 기타 작업이 이진 검색의 원리를 사용할 수 있다
- 트리(또는 새 키를 삽입할 장소)에서 키를 찾을 때, 트리를 루트 노드부터 말단 노드까지 가로지르며, 트리의 노드에 저장된 키와 비교하고, 그 비교에 기초하여 왼쪽 또는 오른쪽 하위 트리에서 계속 검색하기로 결정한다
- 평균적으로, 이것은 각 비교가 트리의 약 절반을 건너뛸 수 있다는 것을 의미하며, 따라서 각 검색, 삽입 또는 삭제는 트리에 저장된 아이템 수의 로그에 비례하는 시간이 소요된다
- 이것은 (정렬되지 않은) 배열에서 키별로 아이템을 찾는 데 필요한 선형 시간보다 훨씬 빠르지만 해시 테이블에 대한 해당 작업보다 느리다

<br />

### AVL 트리

![AVL Tree](https://upload.wikimedia.org/wikipedia/commons/f/fd/AVL_Tree_Example.gif)

🔼 AVL 트리에 여러 요소를 삽입하는 모습을 보여주는 애니메이션 (왼, 오, 왼-오, 오-왼 회전)

![AVL Tree](https://upload.wikimedia.org/wikipedia/commons/a/ad/AVL-tree-wBalance_K.svg)

- 발명자 이름인 Adelson-Velsky and Landis에서 따온 이름
- 자가 균형 이진 탐색 트리
- 자가 균형 데이터 구조 중 처음으로 발명되었다
- 어떤 노드든 두 자식 서브트리의 높이는 최대 1만큼 차이가 난다
- 만약 어떤 시점에서 높이 차이가 1보다 커지면, 이 속성을 유지하기 위하여 스스로 균형을 잡는다
- 검색, 삽입, 삭제는 모두 평균과 최악의 경우 O(logn)의 시간복잡도가 걸린다 (n은 작업 전 트리의 노드 수)
- 삽입과 삭제는 한 번 이상의 트리 회전을 통해 트리의 균형을 재조정해야 할 수 있다

<br />

### Red-Black 트리

![red-black tree](https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_example.svg)

- 일종의 자가 균형 이진 탐색 트리로, 대표적으로는 연관 배열 등을 구현하는데 쓰이는 자료구조
- 이진 트리의 각 노드에는 추가 비트가 있으며, 이 비트는 노드의 색상(빨간색 또는 검정색)으로 해석되기도 한다
- 이러한 색 비트는 삽입 및 삭제 중에 트리가 대략적으로 균형을 유지하도록 하는 데 사용된다
- 트리의 각 노드를 특정 속성을 만족시키는 방식으로 두 가지 색상 중 하나로 칠함으로써 균형이 유지되며, 이는 최악의 경우 트리가 얼마나 불균형해질 수 있는지를 집합적으로 제한한다
- 자료의 삽입과 삭제, 검색에서 최악의 경우에도 일정한 실행 시간을 보장한다(worst-case guarantees)
- AVL 트리는 레드-블랙 트리보다 더 엄격하게 균형이 잡혀 있기 때문에, 삽입과 삭제를 할 때 최악의 경우에는 더 많은 회전(rotations)이 필요
- 트리가 수정되면 새 트리가 다시 정렬되고 다시 칠해져 색칠 속성을 복원한다
- 속성은 이러한 재배열 및 회수가 효율적으로 수행될 수 있도록 설계된다
- 트리의 균형은 완벽하지 않지만 O(log n) 시간 내에 검색을 보장하기에 충분하다 (n은 트리의 총 요소 수)
- 삽입 및 삭제 작업 또한 트리 재배열 및 재채색과 함께 O(log n) 시간안에 수행된다

<br />

### 세그먼트 트리

![Min Segment Tree](https://www.geeksforgeeks.org/wp-content/uploads/RangeMinimumQuery.png)

🔼 Min Segment Tree

![Sum Segment Tree](https://www.geeksforgeeks.org/wp-content/uploads/segment-tree1.png)

🔼 Sum Segment Tree

- a.k.a. 통계 트리
- 간격 또는 세그먼트에 대한 정보를 저장하는 데 사용되는 트리 데이터 구조
- 저장된 세그먼트 중 지정된 포인트가 포함된 세그먼트를 쿼리할 수 있다
- 원칙적으로 정적 구조 (즉, 한 번 빌드되면 수정할 수 없는 구조)
- 유사한 데이터 구조가 [간격 트리](https://en.wikipedia.org/wiki/Interval_tree)

<br />

- 간격 또는 세그먼트 의 집합 I 이 주어지면 I 에 대한 세그먼트 트리 _T_ 는 다음과 같이 구성된다
  - T 는 이진 트리
  - 그것의 리프는 I 의 끝점에 의해 유도된 기본 간격에 순서대로 대응한다  
    가장 왼쪽 잎은 가장 왼쪽 간격에 대응하는 식  
    잎 v 에 해당하는 기본 간격 은 Int( v )로 표시된다
  - T 의 내부 노드는 기본 간격 의 합집합인 간격에 해당한다  
    노드 N 에 해당하는 간격 Int( N )은 N 을 근간으로 하는 트리의 잎에 해당하는 간격의 합집합  
    이는 Int( N )이 두 자식 간격의 합집합임을 의미한다
  - T 의 각 노드 또는 리프 v 는 일부 데이터 구조에서 간격 Int( v ) 및 간격 세트를 저장한다  
    노드 v 의 이 정규 부분집합 에는 \[ x , x' \] 에 Int( v )가 포함되고 Int(parent( v ))가 포함되지 않도록 I 의 구간 \[ x , x' \] 가 포함된다  
    즉, T 의 각 노드는 해당 간격에 걸쳐 있지만 부모의 간격을 통해 확장되지 않는 세그먼트를 저장한다

<br />

- 세그먼트 트리는 이진 트리
- 트리의 루트는 전체 배열을 나타낸다
- 루트의 두 자식은 배열의 첫 번째, 두 번째 부분을 나타낸다
- 마찬가지로 각 노드의 자식은 노드에 해당하는 배열의 두 절반에 해당한다
- 각 노드 값이 자식 값의 "최소"(또는 다른 함수)가 되도록 트리를 상향식으로 구축 (O(n log n) 시간이 걸림)
- 수행된 작업의 수는 트리의 높이인 O(log n)이다
- 레인지 쿼리를 수행하기 위해 각 노드는 커리를 자식마다 하나의 하위 쿼리인 두 부분으로 나눈다
- 만약 쿼리에 노드의 전체 하위 배열이 포함된 경우 노드에서 미리 계산된 값을 사용할 수 있다
- 이 최적화를 사용하면 O(log n) 최소 연산만 수행된다는 것을 증명할 수 있다

<br />

### Fenwick 트리

![Binary Indexed Tree](https://www.geeksforgeeks.org/wp-content/uploads/BITSum.png)

![Fenwick Tree](https://upload.wikimedia.org/wikipedia/commons/d/dc/BITDemo.gif)

🔼 하나씩 삽입하여 배열 \[1, 2, 3, 4, 5\]에 대한 이진 인덱스 트리 생성

- 이진 인덱스 트리 (binary indexed tree) 라고도 한다
- 요소를 효율적으로 업데이트하고 숫자 테이블에서 접두사 합계를 계산할 수 있는 데이터 구조
- 편평한 수의 배열과 비교할 때, 펜윅 트리는 두 연산 사이에서 훨씬 더 나은 균형을 이룬다
- 평평한 숫자 배열과 비교할 때 펜윅 트리는 요소 업데이트와 접두사 합계 계산이라는 두 가지 작업 간에 훨씬 더 나은 균형을 이룬다
- n개 숫자의 평평한 배열에서 요소 또는 접두사 합계를 저장할 수 있다- 첫 번째 경우 접두사 합계를 계산하려면 선형 시간이 필요하고,
- 두 번째 경우 배열 요소를 업데이트하려면 선형 시간이 필요하다 (두 경우 모두 다른 연산은 일정한 시간에 수행될 수 있다)
- 펜윅 트리는 두 작업을 모두 O(log n) 시간에 수행할 수 있도록 한다
- 이것은 각 노드의 값이 해당 하위 트리의 숫자의 합인 트리로 숫자를 표현함으로써 달성된다
- 트리 구조를 통해 O(log n) 노드 액세스만 사용하여 작업을 수행할 수 있다

<hr />

## 그래프

![Graph](https://www.tutorialspoint.com/data_structures_algorithms/images/graph.jpg)

- 수학, 특히 그래프 이론의 분야에서 무방향 그래프와 방향 그래프 개념을 구현하기 위한 추상 데이터 유형
- 그래프 데이터 구조는 무방향 그래프의 경우 이러한 꼭짓점의 정렬되지 않은 쌍 집합 또는 방향 그래프의 경우 순서 쌍 집합과 함께, 유한한(및 변경 가능한) 꼭짓점 집합( 노드 또는 점 이라고도 함 )으로 구성된다
- 이러한 쌍을 무방향 그래프의 경우 edges, arcs 또는 lines이라고 하며, 방향 그래프의 경우 arrows, directed edges, directed arcs 또는 directed lines라고 한다
- 꼭짓점은 그래프 구조의 일부이거나 정수 인덱스 또는 참조로 표현되는 외부 엔티티일 수 있다

<hr />

## 서로소 집합

![disjoint set](https://upload.wikimedia.org/wikipedia/commons/6/67/Dsu_disjoint_sets_init.svg)

MakeSet creates 8 singletons.

![disjoint set](https://upload.wikimedia.org/wikipedia/commons/a/ac/Dsu_disjoint_sets_final.svg)

After some operations of Union, some sets are grouped together.

- union-find 데이터 구조 또는 merge-find set 이라고도 한다
- 여러 개의 서로소 (서로 중복되지 않는) 부분 집합으로 분할된 요소 집합을 추적하는 데이터 구조
- 새로운 집합을 추가하고, 기존 집합을 병합하고, 요소가 동일한 집합에 있는지 여부를 결정하기 위해 역 애커만 함수에 의해 제한되는 거의 일정한 시간(near-constant-time) 연산을 제공한다
- 많은 다른 용도(응용프로그램 섹션 참조) 외에도, 서로소 집합은 그래프의 최소 스패닝 트리를 찾는 크루스칼 알고리즘에서 중요한 역할을 한다

<hr />

## 블룸 필터

![Bloom Filter](https://upload.wikimedia.org/wikipedia/commons/a/ac/Bloom_filter.svg)

- 한 요소가 집합에 존재하는지 여부를 테스트하기 위해 설계된 공간 효율적인 확률적 데이터 구조
- 잠재적인 거짓 양성을 비용으로 엄청나게 빠르고 최소한의 메모리를 사용하도록 설계되었다
  - 거짓 양성(false positive, 1종오류): 실제로는 음성인데 검사 결과는 양성이라고 나오는 것  
    (예: 어떤 메일이 스팸 메일인지 검사하는 프로그램에서, 어떤 메일이 실제로는 스팸 메일이 아니지만 프로그램 검사 결과 스팸 메일이라고 판정하는 것)
  - 거짓 음성(false negative, 2종오류): 실제로는 양성인데 검사 결과는 음성이라고 나오는 것  
    (예: 어떤 메일이 스팸 메일인지 검사하는 프로그램에서, 어떤 메일이 실제로는 스팸 메일임에도 불구하고 프로그램 검사 결과 스팸 메일이 아니라고 판정하는 것)
- 블룸 필터에 의해 어떤 원소가 집합에 속한다고 판단된 경우 실제로는 원소가 집합에 속하지 않는 거짓 양성이 발생하는 것이 가능하지만, 반대로 원소가 집합에 속하지 않는 것으로 판단되었는데 실제로는 원소가 집합에 속하는 거짓 음성은 절대로 발생하지 않는다는 특성이 있다
- 거짓 양성 일치는 가능하지만, 거짓 음성은 불가능하다 (즉 쿼리는 "setable in"또는 "definally not in set"을 반환한다)
- 집합에 원소를 추가하는 것은 가능하나, 집합에서 원소를 삭제하는 것은 불가능하다 (블룸 필터 변형 카운팅으로 해결 가능)
- 집합 내 원소의 숫자가 증가할수록 거짓 양성 발생 확률도 증가한다
- 기존의 오류 없는 해싱 기술을 적용할 경우, 소스 데이터 양이 비실용적으로 많은 양의 메모리를 필요로하는 애플리케이션을 위한 기술을 제안
