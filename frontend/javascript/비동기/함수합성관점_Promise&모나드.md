> 인프런 유인동 지식공유자님의 `함수형 프로그래밍과 JavaScript ES6+` 강의를 참고하였습니다

## Function Composition (함수 합성)

- Promise는 비동기 상황에서 함수 합성을 안전하게 하기 위한 도구
- 비동기 값을 가지고 연속적인 함수 실행을 안전하게 하는 `모나드`
  - JS는 동적 타입 언어이고, 타입을 중심으로 사고하며 프로그래밍하는 언어는 아니기 때문에 모나드나 대수 구조의 타입 등이 묻어나지 않는 경향이 있다.
  - JS에서는 직접적으로 모나드를 활용하며 프로그래밍하지는 않는다.
- 실제 JS 같은 클로저나 동적 타입 언어에서 함수형 프로그래밍을 할 때 모나드라는 개념을 중시하지는 않는다. (모나드라는 값이나 객체가 없기 때문)
- Array나 Promise를 통해 모나드가 무엇인지 알 수 있고, 모나드의 함수 합성에서의 안전성을 살펴볼 수 있다.
- 모나드는 결국 함수 합성을 안전하게 하기 위한 도구

```javascript
// f . g
// f(g(x))

const g = (a) => a + 1;
const f = (a) => a * a;

console.log(f(g(1))); // 4
console.log(f(g())); // NaN
```

- g에게 전달되는 값이 어떤 값이 올 지 알 수 없는 현실 프로그래밍 세상에선, log를 출력하지 않고 외부에 영향을 주고 싶지 않음에도 결과가 출력된다.
- g에는 함수 합성이 동작할 수 있는 안전한 인자만 들어올 수 있어야 한다.
- 어떤 값이 들어올지 모르는, 있을지 없을지 모르는 함수 합성을 어떻게 안전하게 할 수 있을까? -> `모나드`

<br />

- 모나드는 박스를 가지고 있고, 박스 안에 실제 효과 또는 연산에 필요한 재료 가지고 있다
- 박스가 가지고 있는 메서드(map)를 통해 함수 합성을 한다.

```javascript
const g = (a) => a + 1;
const f = (a) => a * a;

console.log([1].map(g).map(f)); // [4]
// 어레이는 필요한 값이 아니다
// 어레이는 개발자가 어떤 효과를 만들거나 값들을 다룰 때 사용하는 도구일 뿐 사용자에게 필요한 결론은 아니다

[1]
  .map(g) // [2]
  .map(f) // [4]
  .forEach((r) => console.log(r)); // 4

// 이렇게 합성했을 때의 이점
[]
  .map(g)
  .map(f)
  .forEach((r) => console.log(r)); // 아무 일도 일어나지 않는다
// 아무 값이 안들어와서 출력이 안되는 것이 아니라, 함수 자체가 실행이 안된 것
// 박스 안에 효과가 있는지 없는지에 따라서 함수 합성을 안전하게 하고 있다는 의미
// console.log(f(g()))의 경우 빈 값이 들어와도 강제 함수 실행이 되며 효과까지 일으킨다.
// 모나드 형태의 어레이로 map을 통해 함수 합성을 했을 때, 빈 값이 들어오면 안전하게 효과를 아예 일으키지 않게 된다.
```

- 순수 함수를 통한 합성까지는 사용자에게 필요한 효과는 없는 상태
- 이후 실제 사용자에게 필요한 효과(출력, html요소로 변환 등)까지 가기 전에 안전하게 함수를 합성해놓는 기법

### 중간에 filter를 넣어서 일부 값만 동작하도록 할 수도 있다

```javascript
[1, 2, 3]
  .map(g) // [2 ,3, 4]
  .filter((a) => a % 2) // [3]
  .map(f) // [9]
  .forEach((r) => console.log(r));
// 9
```

### Promise는 어떠한 함수 합성을 하는 값?

- Promise도 어레이와 완전히 동일한 표현
- 딜레이가 필요한 비동기적으로 일어나는 상황에서 안전하게 함수를 합성하기 위한 도구

```javascript
// Array는 map을 통해 함수 합성
Array.of(1) // [1]
  .map(g)
  .map(f)
  .forEach((r) => console.log(r)); // 4

// Promise는 then을 통해 함수 합성
Promise.resolve(1) // Promise {<sesolved>: 1}
  .then(g)
  .then(f)
  .then((r) => console.log(r)); // 4

// 용도가 다르다 (잘못된 값이 효과까지 일으킨다)
// 프로미스는 안에 어떤 값이 있거나 없거나 관점에서 안전한 합성을 하려는 것이 아니라, 비동기 상황에서의 합성을 안전하게 하려는 것
Promise.resolve()
  .then(g)
  .then(f)
  .then((r) => console.log(r)); // NaN

// 안에 들어가는 값이 100ms 후 알 수 있는 값인 비동기 상황일 경우
new Promise((resolve) => setTimeout(() => resolve(2), 100))
  .then(g)
  .then(f)
  .then((r) => console.log(r)); // 9
```
